<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Futuristic Map - Mapbox</title>

    <!-- Mapbox GL JS CSS (CDN) -->
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />

    <style>
      :root{
        --bg: #061016;
        --panel: rgba(10,12,16,0.7);
        --accent: #00e6ff;
        --muted: #99a1a7;
      }
      html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial}
      #map{position:fixed;top:0;left:0;right:0;bottom:0}

      .panel{
        position:absolute;left:16px;top:16px;z-index:3;width:300px;padding:14px;border-radius:10px;color:#cfeff4;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));backdrop-filter: blur(6px);box-shadow:0 6px 30px rgba(0,0,0,0.6);
      }
      .panel h1{margin:0 0 8px 0;font-size:18px}
      .panel p{margin:0;color:var(--muted);font-size:13px}
      .btn{margin-top:12px;background:transparent;border:1px solid rgba(0,230,255,0.18);color:var(--accent);padding:8px 12px;border-radius:8px;cursor:pointer}

      .marker {
        width:18px;height:18px;border-radius:50%;background:linear-gradient(180deg,var(--accent),#00b3cc);box-shadow:0 0 14px rgba(0,230,255,0.25);border:2px solid rgba(255,255,255,0.06);
      }
      .small-marker{
        width:10px;height:10px;border-radius:50%;background:linear-gradient(180deg,var(--accent),#00b3cc);box-shadow:0 0 10px rgba(0,230,255,0.18);border:1px solid rgba(255,255,255,0.04);
      }

      .infocard{
        position:absolute;right:16px;bottom:16px;z-index:4;padding:12px;border-radius:8px;background:rgba(7,16,23,0.9);color:#cfeff4;border:1px solid rgba(0,230,255,0.06);min-width:220px;backdrop-filter: blur(6px);
      }

      @media(max-width:720px){.panel{left:8px;right:8px;width:auto}}
    </style>
  </head>
  <body>
    <div id="map"></div>

    <div class="panel">
      <h1>Futuristic Wine Map</h1>
      <p>A map that shows international wine growing regions and German parcels</p>
      <button class="btn" id="fly-berlin">Fly to Berlin</button>
      <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap">
        <button class="btn" id="zoom-data">Zoom to data</button>
        <button class="btn" id="toggle-points">Toggle points</button>
        <button class="btn" id="toggle-polygons">Toggle polygons</button>
      </div>
    </div>

    <div id="infocard" class="infocard" style="display:none">
      <strong id="info-title"></strong>
      <div id="info-desc" style="font-size:13px;color:#9bbec3;margin-top:6px">A futuristic Gotham-style info card.</div>
      <div style="margin-top:8px"><button id="close-info" class="btn" style="border-color:rgba(255,255,255,0.04);color:#9ddbf0;padding:6px 10px">Close</button></div>
    </div>

    <!-- Visible status/debug box -->
    <div id="status" style="position:absolute;right:16px;top:16px;z-index:6;padding:8px 10px;border-radius:8px;background:rgba(3,10,14,0.7);color:#9ddbf0;font-size:13px;border:1px solid rgba(0,230,255,0.06);backdrop-filter:blur(4px);">Loading...</div>

    <!-- Prefetch datasets into window to ensure availability and for debugging -->
    <script>
      (async function(){
        const status = document.getElementById('status');
        try{
          const [d1, d2] = await Promise.all([
            fetch('/data/Weinanbaugebiete.json').then(r=>r.json()).catch(()=>null),
            fetch('/data/Deutsche_Weinlagen.json').then(r=>r.json()).catch(()=>null)
          ]);
          window.WEIN_DATA = d1;
          window.DE_DATA = d2;

          const parts = [];

          // points count
          let pointsCount = 0;
          if(d2){
            if(Array.isArray(d2.items)) pointsCount = d2.items.length;
            else if (typeof d2 === 'object') pointsCount = Object.values(d2).length;
          }
          parts.push('Points: '+pointsCount);

          // polygons count
          let polyItems = 0, polyFeatures = 0;
          if(d1 && Array.isArray(d1.items)){
            polyItems = d1.items.length;
            for(const it of d1.items) if(it.polygons && Array.isArray(it.polygons)) polyFeatures += it.polygons.length;
          }
          parts.push('Polygon items: '+polyItems);
          parts.push('Polygon features: '+polyFeatures);

          // compute bounds from both datasets (best-effort)
          let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
          if(d2){
            const items = Array.isArray(d2.items) ? d2.items : Object.values(d2);
            for(const it of items){
              const lat = Number(it.geo_lat ?? it.lat ?? it.latitude);
              const lng = Number(it.geo_lng ?? it.lng ?? it.longitude);
              if(!Number.isNaN(lat) && !Number.isNaN(lng)){
                if(lng<minX) minX=lng; if(lat<minY) minY=lat; if(lng>maxX) maxX=lng; if(lat>maxY) maxY=lat;
              }
            }
          }
          if(d1 && Array.isArray(d1.items)){
            for(const it of d1.items){
              if(!it.polygons) continue;
              for(const poly of it.polygons){
                for(const pt of poly){
                  const lon = Number(pt[0]), lat = Number(pt[1]);
                  if(!Number.isNaN(lat) && !Number.isNaN(lon)){
                    if(lon<minX) minX=lon; if(lat<minY) minY=lat; if(lon>maxX) maxX=lon; if(lat>maxY) maxY=lat;
                  }
                }
              }
            }
          }
          if(isFinite(minX)) window.__DATA_BOUNDS = [[minX,minY],[maxX,maxY]];

          status.textContent = parts.join(' | ') || 'Data loaded';
        }catch(err){
          console.error('Prefetch failed', err);
          if(status) status.textContent = 'Data prefetch failed';
        }
      })();
    </script>

    <!-- Load local, git-ignored token file (create frontend/token.js containing window.MAPBOX_TOKEN) -->
    <script src="/token.js"></script>

    <!-- Mapbox GL JS (CDN) -->
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
    <script>
      // Mapbox token: read from a local, git-ignored file that sets window.MAPBOX_TOKEN
      // Create `frontend/token.js` with: window.MAPBOX_TOKEN = 'pk.your_token_here';
      const MAPBOX_TOKEN = window.MAPBOX_TOKEN || null;
      if(!MAPBOX_TOKEN){
        console.error('Mapbox token missing. Create frontend/token.js with: window.MAPBOX_TOKEN = "pk..." and ensure it is gitignored.');
        const statusEl = document.getElementById('status');
        if(statusEl) statusEl.textContent = 'ERROR: Mapbox token missing â€” create frontend/token.js (gitignored)';
      }
      mapboxgl.accessToken = MAPBOX_TOKEN;

      // Create map
      const map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/dark-v10',
        center: [13.404954, 52.520008],
        zoom: 6,
        pitch: 40,
        bearing: -10
      });

      // Add navigation control
      map.addControl(new mapboxgl.NavigationControl({showCompass:true, showZoom:true}), 'top-right');

      // Load Deutsche_Weinlagen and add as a clustered GeoJSON source + circle layers
      async function loadDeutscheWeinlagen(){
        try{
          console.log('Loading Deutsche_Weinlagen...')
          const raw = window.DE_DATA || await (await fetch('/data/Deutsche_Weinlagen.json')).json();
          const items = raw.items || Object.values(raw) || [];

          const features = [];
          for(const item of items){
            const tryLat = item.geo_lat || item.lat || item.latitude || item.LAT || null;
            const tryLng = item.geo_lng || item.lng || item.longitude || item.LNG || null;
            if(!tryLat || !tryLng) continue;
            const latNum = Number(tryLat);
            const lngNum = Number(tryLng);
            if(Number.isNaN(latNum) || Number.isNaN(lngNum)) continue;

            const props = Object.assign({}, item);
            // ensure strings/primitive safe
            for(const k in props){
              if(typeof props[k] === 'object') props[k] = JSON.stringify(props[k]);
            }

            features.push({
              type: 'Feature',
              geometry: {type: 'Point', coordinates: [lngNum, latNum]},
              properties: props
            });
          }

          const geojson = {type:'FeatureCollection', features};
          console.log('Deutsche_Weinlagen features:', features.length);
          // update visible status
          const statusEl = document.getElementById('status');
          if(statusEl) statusEl.textContent = `Points: ${features.length}`;

          // if source exists, update data
          if(map.getSource('points')){
            map.getSource('points').setData(geojson);
            return;
          }

          map.addSource('points', {
            type: 'geojson',
            data: geojson,
            cluster: true,
            clusterMaxZoom: 14,
            clusterRadius: 50
          });

          // clustered circles
          map.addLayer({
            id: 'clusters',
            type: 'circle',
            source: 'points',
            filter: ['has', 'point_count'],
            paint: {
              'circle-color': ['step', ['get', 'point_count'], '#00e6ff', 100, '#00b3cc', 750, '#008ba3'],
              'circle-radius': ['step', ['get', 'point_count'], 12, 100, 18, 750, 24],
              'circle-opacity': 0.9
            }
          });

          // cluster count labels
          map.addLayer({
            id: 'cluster-count',
            type: 'symbol',
            source: 'points',
            filter: ['has', 'point_count'],
            layout: {
              'text-field': '{point_count_abbreviated}',
              'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
              'text-size': 12
            },
            paint: {
              'text-color': '#001b1f'
            }
          });

          // unclustered points
          map.addLayer({
            id: 'unclustered-point',
            type: 'circle',
            source: 'points',
            filter: ['!', ['has', 'point_count']],
            paint: {
              'circle-radius': 6,
              'circle-color': '#00e6ff',
              'circle-stroke-color': '#0ff',
               'circle-stroke-width': 1.5,
               'circle-opacity': 0.95
             }
           });

          // ensure point layers are above glow (move to top)
          try{ map.moveLayer('unclustered-point'); }catch(e){}
          try{ map.moveLayer('cluster-count'); }catch(e){}
          try{ map.moveLayer('clusters'); }catch(e){}

           // click cluster to zoom
           map.on('click', 'clusters', function (e) {
            const features = map.queryRenderedFeatures(e.point, { layers: ['clusters'] });
            const clusterId = features[0].properties.cluster_id;
            map.getSource('points').getClusterExpansionZoom(clusterId, function (err, zoom) {
              if (err) return;
              map.easeTo({ center: features[0].geometry.coordinates, zoom: zoom });
            });
          });

          // click unclustered point -> show info
          map.on('click', 'unclustered-point', function(e){
            const f = e.features && e.features[0];
            if(!f) return;
            // properties were stringified where necessary
            const props = Object.assign({}, f.properties);
            // parse any JSON strings back safely (best-effort)
            for(const k in props){
              const v = props[k];
              if(typeof v === 'string' && v.startsWith('{') && v.endsWith('}')){
                try{ props[k] = JSON.parse(v); }catch(err){}
              }
            }
            // show info using existing card format
            showInfo(props);
          });

          // pointer cursor on hover
          map.on('mouseenter', 'clusters', ()=> map.getCanvas().style.cursor='pointer');
          map.on('mouseleave', 'clusters', ()=> map.getCanvas().style.cursor='');
          map.on('mouseenter', 'unclustered-point', ()=> map.getCanvas().style.cursor='pointer');
          map.on('mouseleave', 'unclustered-point', ()=> map.getCanvas().style.cursor='');

        }catch(err){
          console.error('Failed to load Deutsche_Weinlagen:', err);
        }
      }


      // Load Weinanbaugebiete polygons and add to map
      async function loadWeinanbaugebiete(){
        try{
          console.log('Loading Weinanbaugebiete...');
          const raw = window.WEIN_DATA || await (await fetch('/data/Weinanbaugebiete.json')).json();

          const features = [];
          for(const item of (raw.items||[])){
            if(!item.polygons || !item.polygons.length) continue;
            for(const poly of item.polygons){
              const ring = poly.map(pt => [Number(pt[0]), Number(pt[1])]);
              features.push({
                type: 'Feature',
                geometry: {type: 'Polygon', coordinates: [ring]},
                properties: item
              });
            }
          }

          const geojson = {type:'FeatureCollection', features};
          console.log('Weinanbaugebiete polygon features:', features.length);
          // update visible status (append)
          const statusEl2 = document.getElementById('status');
          if(statusEl2) statusEl2.textContent = (statusEl2.textContent ? statusEl2.textContent + ' | ' : '') + `Polygon features: ${features.length}`;

          if(map.getSource('wein')){
            try{ map.removeLayer('wein-fill'); }catch(e){}
            try{ map.removeLayer('wein-line'); }catch(e){}
            try{ map.removeSource('wein'); }catch(e){}
          }

          map.addSource('wein', {type:'geojson', data: geojson});

          map.addLayer({
            id: 'wein-fill',
            type: 'fill',
            source: 'wein',
            paint: {
              'fill-color': 'rgba(0,230,255,0.18)',
              'fill-outline-color': 'rgba(0,230,255,0.36)'
            }
          });

           map.addLayer({
             id: 'wein-line',
             type: 'line',
             source: 'wein',
             paint: {
              'line-color': 'rgba(0,230,255,0.5)',
              'line-width': 1.6
            }
          });

          // click handler
          map.on('click', 'wein-fill', function(e){
            const f = e.features && e.features[0];
            if(!f) return;
            const props = f.properties || {};
            // if any props are JSON strings, parse
            for(const k in props){
              if(typeof props[k] === 'string' && props[k].startsWith('{') && props[k].endsWith('}')){
                try{ props[k] = JSON.parse(props[k]); }catch(err){}
              }
            }
            showInfo(props);
          });

          // hover highlight effect
          map.on('mouseenter', 'wein-fill', ()=>{
            map.setPaintProperty('wein-fill','fill-color','rgba(0,230,255,0.26)');
            map.getCanvas().style.cursor='pointer';
          });
          map.on('mouseleave', 'wein-fill', ()=>{
            map.setPaintProperty('wein-fill','fill-color','rgba(0,230,255,0.18)');
            map.getCanvas().style.cursor='';
          });

          // move polygon layers above glow and point layers to ensure visibility
          try{ map.moveLayer('wein-line'); }catch(e){}
          try{ map.moveLayer('wein-fill'); }catch(e){}

          // compute bounds for zoom-to-data
          (function computeBounds(){
            const pts = features.map(f=>f.geometry.coordinates);
            const polys = features; // not used here
            let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
            for(const f of features){
              const c = f.geometry.coordinates;
              if(f.geometry.type==='Point'){
                const [x,y]=c; if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y;
              }
            }
            // if we computed a valid bbox, store
            if(isFinite(minX)) window.__DATA_BOUNDS = [[minX,minY],[maxX,maxY]];
          })();

          // update status with bounds info
          if(window.__DATA_BOUNDS){
            const sb = document.getElementById('status');
            if(sb) sb.textContent = (sb.textContent||'') + ' | bounds set';
          }

        }catch(err){
          console.error('Failed to load Weinanbaugebiete:', err);
        }
      }

      // Show info card
      function showInfo(loc){
        const title = loc.bezeichnung || loc.label || loc.name || loc.lage || 'Feature';
        document.getElementById('info-title').textContent = title;
        const descEl = document.getElementById('info-desc');
        const lines = [];
        if(loc.land_bezeichnung) lines.push(`<strong>Country/Region:</strong> ${loc.land_bezeichnung}`);
        if(loc.bundesland) lines.push(`<strong>Bundesland:</strong> ${loc.bundesland}`);
        if(loc.infos) lines.push(`<strong>Info:</strong> ${loc.infos}`);
        if(loc.anbauName) lines.push(`<strong>Anbau:</strong> ${loc.anbauName}`);
        if(loc.lage) lines.push(`<strong>Lage:</strong> ${loc.lage}`);
        if(loc.gemeinde) lines.push(`<strong>Gemeinde:</strong> ${loc.gemeinde}`);
        if(loc.rebsorten) lines.push(`<strong>Grapes:</strong> ${loc.rebsorten}`);
        if(loc.winzer) lines.push(`<strong>Winzer:</strong> ${loc.winzer}`);
        if(loc.weine) lines.push(`<strong>Weine:</strong> ${loc.weine}`);
        const area = loc.flaeche || loc.area;
        if(area) lines.push(`<strong>Area (ha):</strong> ${area}`);
        if(lines.length===0 && (loc.info || loc.infos)) lines.push(loc.info || loc.infos);
        lines.push(`<em style="color:#7eaeb6;margin-top:6px;display:block">ID: ${loc.id || 'n/a'}</em>`);
        descEl.innerHTML = lines.join('<br/>') || 'No additional information available.';
        document.getElementById('infocard').style.display = 'block';
        if(loc.geo_lng && loc.geo_lat){
          const lng = Number(loc.geo_lng), lat = Number(loc.geo_lat);
          map.easeTo({center:[lng,lat], zoom: loc.geo_zoom||11, duration:1000});
        } else if(loc.geometry && loc.geometry.coordinates){
          // center to feature geometry if available
          const coords = loc.geometry.coordinates || loc.coords;
          if(Array.isArray(coords)) map.easeTo({center: coords, zoom: 11, duration:1000});
        } else if(loc.coords){
          map.easeTo({center: loc.coords, zoom: 11, duration:1000});
        }
       }

      document.getElementById('close-info').addEventListener('click', ()=>{
        document.getElementById('infocard').style.display = 'none';
      });

      document.getElementById('fly-berlin').addEventListener('click', ()=>{
        map.flyTo({center:[13.404954,52.520008], zoom:10, speed: 0.8});
      });

      map.on('load', ()=>{
        // Add a faint glow circle around Berlin as a design accent (add first so it sits underneath data layers)
        map.addSource('glow', {
          type: 'geojson',
          data: {
            type: 'FeatureCollection',
            features: [
              {type:'Feature', geometry:{type:'Point', coordinates:[13.404954,52.520008]}}
            ]
          }
        });

        map.addLayer({
          id: 'glow-layer',
          type: 'circle',
          source: 'glow',
          paint: {
            'circle-radius': [
              'interpolate', ['linear'], ['zoom'],
              6, 30,
              12, 140
            ],
            'circle-color': 'rgba(0,230,255,0.05)',
            'circle-blur': 1
          }
        });

        // load datasets after glow to ensure datasets render above glow
        loadWeinanbaugebiete();
        loadDeutscheWeinlagen();

        // wire up UI buttons
        document.getElementById('zoom-data').addEventListener('click', ()=>{
          if(window.__DATA_BOUNDS){
            map.fitBounds(window.__DATA_BOUNDS, {padding:50});
          } else {
            // fallback: fit to default germany bbox
            map.fitBounds([[5.5,47.2],[15.5,55.1]], {padding:50});
          }
        });

        // toggles
        let pointsVisible = true, polysVisible = true;
        document.getElementById('toggle-points').addEventListener('click', ()=>{
          pointsVisible = !pointsVisible;
          const vis = pointsVisible ? 'visible' : 'none';
          ['clusters','cluster-count','unclustered-point'].forEach(id=>{ try{ map.setLayoutProperty(id,'visibility',vis);}catch(e){} });
        });
        document.getElementById('toggle-polygons').addEventListener('click', ()=>{
          polysVisible = !polysVisible;
          const vis = polysVisible ? 'visible' : 'none';
          ['wein-fill','wein-line'].forEach(id=>{ try{ map.setLayoutProperty(id,'visibility',vis);}catch(e){} });
        });

        // debug: list sources and layers
        console.log('Map sources after load:', Object.keys(map.getStyle().sources));
        console.log('Map layers after load:', map.getStyle().layers && map.getStyle().layers.map(l=>l.id));
      });

      // Basic error handling: if the map fails to load, show an overlay message
      map.on('error', (e)=>{
        console.error('Map error', e.error);
        const panel = document.querySelector('.panel');
        panel.innerHTML += '<div style="margin-top:10px;color:#ff6b6b">Map failed to load. Check token & network.</div>';
      });
    </script>
  </body>
</html>
